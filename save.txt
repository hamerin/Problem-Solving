// MATRIX CLASS

#define MOD 1000000007

class matrix {
public:
  vector<vector<ll> > Matrix;
  matrix(int N, int M) {
    Matrix.resize(N, vector<ll>(M));
  }
  matrix(vector<vector<ll> > _mat) {
    Matrix=_mat;
  }
  void print() {
    for(auto i:Matrix) {
      for(auto j:i) {
        printf("%lld ", j);
      }
      printf("\n");
    }
  }
  matrix operator*(const matrix &rhs);
  matrix& operator=(const matrix &rhs);
};

matrix matrix::operator*(const matrix &rhs) {
  matrix result=matrix(this->Matrix.size(), rhs.Matrix[0].size());
  for(int i=0; i<this->Matrix.size();i++) {
    for(int j=0;j<rhs.Matrix[0].size();j++) {
      for(int k=0;k<rhs.Matrix.size();k++) {
        result.Matrix[i][j]+=(this->Matrix[i][k] * rhs.Matrix[k][j]);
        result.Matrix[i][j] %= MOD;
      }
    }
  }
  return result;
}

matrix& matrix::operator=(const matrix &rhs) {
  this->Matrix=rhs.Matrix;
  return *this;
}

class disjointSet
{
private:
  vector<int> uf;

public:
  disjointSet(int N)
  {
    uf.clear();
    for (int i = 0; i < N; i++)
      uf.push_back(i);
  }
  int find(int n)
  {
    if (n == uf[n])
      return n;
    return uf[n] = find(uf[n]);
  }
  void merge(int u, int v)
  {
    uf[find(u)] = uf[find(v)];
    return;
  }
  bool isSameset(int u, int v)
  {
    return find(u) == find(v);
  }
};

----------- I HATE 1006 ----------- 

#include <algorithm>
#include <deque>
#include <functional>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <tuple>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#include <cmath>
#include <cstdio>
#include <cstring>

#define iterall(container) container.begin(), container.end()

using namespace std;

using i64 = long long;
using i128 = __int128;
using pi = pair<int, int>;
using pli = pair<i64, i64>;
using ti = tuple<int, int, int>;
using tli = tuple<i64, i64, i64>;

void process() {
  int N, W;
  cin >> N >> W;

  vector<pi> tagon(N + 1);
  for (int i = 1; i <= N; i++) cin >> tagon[i].first;
  for (int i = 1; i <= N; i++) cin >> tagon[i].second;

  int ans = numeric_limits<int>::max();

  for (int rt = 0; rt < 2; rt++) {
    vector<vector<int>> dp(N + 1, vector<int>(3, 1e9));
    dp[0][0] = 0;
    if (tagon[1].first + tagon[1].second <= W)
      dp[1][0] = 1;
    else
      dp[1][0] = 2;
    dp[1][1] = dp[1][2] = 1;

    for (int i = 2; i <= N; i++) {
      bool fi_pos = tagon[i].first + tagon[i - 1].first <= W;
      bool se_pos = tagon[i].second + tagon[i - 1].second <= W;
      bool cur_pos = tagon[i].first + tagon[i].second <= W;

      if (cur_pos) dp[i][0] = min(dp[i][0], dp[i - 1][0] + 1);
      if (fi_pos && se_pos) dp[i][0] = min(dp[i][0], dp[i - 2][0] + 2);
      if (fi_pos) dp[i][1] = min(dp[i][1], dp[i - 1][2] + 1);
      if (se_pos) dp[i][2] = min(dp[i][2], dp[i - 1][1] + 1);

      dp[i][1] = min(dp[i][1], dp[i - 1][0] + 1);
      dp[i][2] = min(dp[i][2], dp[i - 1][0] + 1);
      dp[i][0] = min({dp[i][0], dp[i][1] + 1, dp[i][2] + 1, dp[i - 1][0] + 2});

      // cout << tagon[i].first << " " << tagon[i].second << endl;
      // cout << dp[i][0] << " " << dp[i][1] << " " << dp[i][2] << endl;
    }

    ans = min(ans, dp[N][0]);
    rotate(tagon.begin() + 1, tagon.begin() + 2, tagon.end());
  }

  cout << ans << '\n';
}

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout.tie(nullptr);

  int T;
  cin >> T;

  for (int tc = 0; tc < T; tc++) process();

  return 0;
}